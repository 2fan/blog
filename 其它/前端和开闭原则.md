# 前端和开闭原则

# 前言

在前端工作日趋复杂的今天，需要有良好的设计思想来指导我们进行程序设计，使我们开发出的系统结构优美，更稳定，更易维护，更易扩展，让我们有更多喝喝茶看看书陪陪家人的时间。

# 什么是开闭原则

## 开闭原则的定义

Open-Closed Principle 简称 OCP。

1988年，勃兰特·梅耶(Bertrand Meyer)在他的著作《面向对象软件构造(Object Oriented Software Construction)》中提出了开闭原则，它的原文是这样:Software entities should be open for extension,but closed for modification.

一个软件实体应当对扩展开放,对修改关闭.也就是说,我们在设计一个系统/模块/功能的时候,应当使这个模块可以在不被修改的前提下被扩展,换句话说就是,应当可以在不必修改源代码的情况下改变这个系统/模块/功能的行为.

开闭原则是面向对象设计中"可复用设计"的基石，是面向对象设计中最重要的原则之一，很多的设计模式都是实现开闭原则的一种手段。

## 解读

软件系统的需求变化是一定并且一直存在的，在变化的过程中，已有的模块不被修改或者修改量极少，没有关键路径上的修改，这就使变化中的软件系统有很强的稳定性。

# 如何实现

怎么做到不改代码就能改变原有系统的功能呢。

1. 识别出系统的可变化和可能可变化的点
2. 抽象化可变化的点【接口】，并单独实现可变化的点的抽象【接口的实现】
3. 系统依赖抽象化【接口】而不是依赖于实现。
4. 对实现的路由单独封装，最好以配置的方式提供。（配置不一定是配置文件，可以是代码，但形式一定要简单直观）
5. 需要改变功能的时候，只需要提供新的满足抽象化【接口】的实现，并且更改下路由的配置即可

以上过程，基本实现了对原有代码没有任何修改【对配置的修改不算在内,对配置如果做好约定，也可以不用修改，后面例子会讲到】，就改变了系统原有功能。

## 举个栗子

需求：商品列表中，如果是男装类型，商品背景色使用蓝色，点击后弹出男装的价格；如果是女装，商品背景色使用红色，点击后弹出女装的品牌。

以下伪代码实现：

普通代码,我们可能会这么做：

```
// 渲染html的函数中
if (商品.type === '男装') {
    商品.css(背景色,蓝色);
} else {
   商品.css(背景色，红色);
}


// 点击事件的函数中
if (商品.type === '男装') {
    alert(商品.价格);
} else {
    alert(商品.品牌);
}

```

ok，看起来一切都很好，代码上线了。过了一阵，pm告知添加了一种商品类型，童装，商品背景色使用黄色，点击后弹出童装的销量。

那么，代码会被改成下面这样：

```
// 渲染html的函数中
if (商品.type === '男装') {
    商品.css(背景色,蓝色);
} else if (商品.type === '女装') { // 修改点1 增加女装类型判断
   商品.css(背景色,红色);
} else { // 修改点2 增加童装html渲染处理
   商品.css(背景色,黄色)；
}


// 点击事件的函数中
if (商品.type === '男装') {
    alert(商品.价格);
} else if (商品.type === '女装') { // 修改点3 增加女装类型判断
    alert(商品.品牌);
} else { // 修改点4 增加童装点击处理
    alert(商品.销量);
}
```

ok，以上是可能的正常代码编写方式，当需求发生变化时，会对原有代码很多地方都要进行修改，因为修改的地方过于琐碎，修改后，心里一定会慌慌的，要嘱咐测试多回归回归原有的逻辑，不能只看新的逻辑，同时修改的过程也要火眼金睛，生怕漏掉某一处的修改。。。代码质量可想而知，我们喝喝茶看看书陪家人的时间可能就这样浪费掉了。

下面看一下符合开闭原则的代码：

只有男装和女装的情况：

```
// html渲染的函数中
getManager(商品).设置背景色();

// 点击事件的函数中
getManager(商品).弹出提示();


// getManager的实现
function getManager(商品) {

   if (商品.type === '男装') return 男装manager;

   if (商品.type === '女装') return 女装manager；
}

let 男装manager = {
   设置背景色: function() {
      商品.css(背景色，蓝色);  
   }

   弹出提示: function() {
      alert(商品.价格);
   }
}；

let 女装manager = {
   设置背景色: function() {
      商品.css(背景色，红色);  
   }

   弹出提示: function() {
      alert(商品.品牌);
   }
}；

```
ok，代码量好像多了，多了好几个对象和方法。。。我们接着往下看，当需求发生了变化，童装出现的时候，代码如下：

```
// html渲染的函数中
getManager(商品).设置背景色();

// 点击事件的函数中
getManager(商品).弹出提示();


// getManager的实现
function getManager(商品) {

   if (商品.type === '男装') return 男装manager;

   if (商品.type === '女装') return 女装manager；

   if (商品.type === '童装') return 童装manager；// 修改点1 添加童装管理器的路由，此处可以利用约定的方式而不用修改，后面再讲

}

let 男装manager = {
   设置背景色: function() {
      商品.css(背景色，蓝色);  
   }

   弹出提示: function() {
      alert(商品.价格);
   }
}；

let 女装manager = {
   设置背景色: function() {
      商品.css(背景色，红色);  
   }

   弹出提示: function() {
      alert(商品.品牌);
   }
}；

// 修改点2 添加童装管理器，此处其实不算修改，是新增一个对象
let 童装manager = {
   设置背景色: function() {
      商品.css(背景色，黄色);  
   }

   弹出提示: function() {
      alert(商品.销量);
   }
}；


```

我们可以看到，按照开闭原则设计后的代码，修改点只有一处，修改的地方也可以预判，修改路由方法getManager即可（此处修改其实可以避免）；然后新增一个童装manager即可。

因为修改处变少，我们可以很自信的和测试的同学说，主要测新类型就行了，原来的地方都没改；修改的地方也可以预判到，我们也不会担心遗漏什么修改。

效率不知不觉就提高了，我们多出时间可以喝喝茶看看书陪家人了。


如果getManager也无需修改的话，我们只需约定*manager们的对象命名就可以了，比如，统一使用【商品类型+mannager】命名。示例代码如下：

```

function getManager(商品) {

   // 这里使用window是假设我们的manager都暴露在window对象里
   return window[商品.类型+'manager'];

}

```
按照以上代码，假如现在又加入一个新的类型孕妇装，我们只需实现【孕妇装manager】就可以了，无需修改getmanager的代码，完全的符合开闭原则。

## 接口

接口是面向对象编程语言中很重要的概念，在js语言里其实并没有，不过其实我们已经不知不觉的使用到了接口的概念，比如getManager就返回了一个接口，男装女装童装manager也都实现了这个接口。

前面提到的对变化点的抽象化，其实就是设计一个接口。

### 定义

接口：http://baike.baidu.com/item/%E6%8E%A5%E5%8F%A3/2886384

java接口：http://baike.baidu.com/item/java%E6%8E%A5%E5%8F%A3

一句话理解：接口就是约定。

### 接口的uml类图

http://www.cnblogs.com/AngelLee2009/p/3602499.html

# 设计模式

开闭原则是设计模式的基石，设计模式是前人们验证并总结过的如何在满足开闭原则的条件下设计系统的各种设计方法。

设计模式除了让我们复用大师们的成果，还可以让团队间沟通概念统一，更通顺。

我们前面的设计其实是符合普通工厂模式的。

http://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1212549

# 切忌--过度设计

开闭原则实现的关键点在于抽象化变化，也许我们刚开始不知道该把那部分抽象出来，但是这并不是问题，我们可以遵循简单设计的原则，当变化来了的时候，再重构代码，做到一种满足开闭原则的设计。

切忌到处都抽象化，如果到处都抽象就会导致系统过度设计，过度复杂。这反而是不利于系统的维护。完全的开闭原则是不可能实现的，所以请保持简单设计，在需要的时候做符合开闭原则的设计。

在我们的日常工作中，接到新任务后，在动手前与pm深度的沟通，自己深度的思考，将系统未来可能发生的变化都理解透彻，结合实际情况该抽象化的地方抽象化，不该抽象化的地方简单设计。

# 总结

软件开发过程是条条大路通罗马，让我们选一条最好走的路。

# 后期学习内容推荐

面向对象编程

uml统计建模语言

设计模式


[评论直达连接](https://github.com/cnsnake11/blog/issues/24)
