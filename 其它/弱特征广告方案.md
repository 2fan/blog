# 弱特征广告方案

# 前言

本文参考了以下两篇文章，如有雷同，也是必然。

http://testudy.cc/tech/2016/11/29/ad.html

http://testudy.cc/tech/2016/12/01/ad-manager.html

# 原理

浏览器对广告的屏蔽主要有两种手段，一个是拦截广告相关的请求，一个是使用样式来隐藏掉广告。本文主要针对第二个手段进行若特征处理。

在手段二中，一般浏览器拦截页面内广告会使用css选择器，比如qq浏览器的规则：

```
hide=###app_mask,##.load-app,##div[class^="bbt-pregnant-timeline bbt-pregnant-timeline-"],##div[class^="bottom-layer-"],##div[class="bbt-header-dingtong"],##div[class*="-header-pregnancy"],##div[class*="-footer-pregnancy"],##section[class$="-brand"],##section[class$="-tool"],##div[class$="-footer-expand"]
filter=/base.js?v*&method=$third-party /www/default/base.js$third-party
```

从规则可以看出，弱特征化其实就是将class弱特征化。

# 方案1 纯前端方案

方案描述：

1. 广告模板包括css，html和js，页面直接输出此模板
2. 广告引擎js会读取模板，并将css中的class名称替换成随机，同时替换html和js的class名称
3. 最后将替换后的模板嵌入到页面中

优势：

1. 每次算法都是随机，通过classname来定位广告基本不可能

劣势：

1. 插入html的位置不好确定，位置可能会成为新的特征
2. 广告模板是特征很强的元素，不能加密，直接输出到html中，线索被暴露了
3. 广告模板转换为真正的广告html是一个关键路径方法，理论上，可以通过上述线索较为容易的找到，找到后，浏览器引擎可以在方法执行前，将此方法置空
4. 纯前端渲染，页面会有一定时间的阻塞

总结：

被破解的线索会比较多，会阻塞页面渲染。

# 方案2 前后端结合方案

方案描述：

1. html和css中使用php函数getName(name)来定义class,css要定义在php模板中，不能外联，外联就不能使用php方法了。
2. getName中根据传入的name和盐做md5，将此md5作为返回值
3. js中实现同样的getName函数来计算真实的classname
4. js盐的获取方式要隐藏在页面中
5. 所有的js文件必须加密
6. 盐是随机生成的，由php决定每一次的请求的盐

优势：

1. 因为在html中name是看不到的，只能看到classname，在js里只有name而没有classname，且js文件是加密的，所以在js中不宜搜索，不宜找到关键算法
2. 不会阻塞页面渲染
3. 盐是php定义的，在js获取盐的时候会暴露一次，理论上有暴露的可能性，但几率不高，而且就算暴露了，也还需要破解我们的加盐的位置，这在js里都是加密存放的，难度较大
4. 每次classname都是随机，想要通过classname破解基本不可能。

劣势：

1. 因为把css定义在页面中，使得html文件增大，浪费了流量，还好这个流量不大。

总结：

算法不宜破解，html文件增大

# 方案3 全部使用行内样式

优势：

1. 毫无特征？？？

劣势：

1. 写代码挺费劲。。。
2. 如果js想操作元素，因为毫无特征，好像操作不了了。。。

总结

此路不通，毫无特征对业务js来说也是不行的。

# 结论

我们最后决定使用方案二，虽然有一定的流量的损耗，但不能被破解是我们更关注的点，总不能费半天劲，只能防备一时。

# 改进的思考

方案二的硬伤是css写到了html中，增大了html文件，且不能享用到css外联带来的缓存等好处。也想到了如下的方案进行调整：

方案四：前后端结合且css静态化方案

方案描述：

1. 基本思路同方案二，这里描述不同的点
2. css写到单独的css文件中，在编写css文件中的classname时，使用变量的方式来写，比如.title写成.${title}
3. 与php约定盐的声明，每一个版本都会有多个盐，考虑放到一份配置文件中，php和css处理插件都能读取到即可。
4. 写gulp/grup/webpack插件，在编译css文件时，将变量替换成加盐并md5后的结果，也就是css文件中内置了多套盐产生的classname
5. php在处理每一次请求中，随机决定使用哪个盐，并告知js。

优势：

1. 方案二的优点加上可以将css文件外联引用

劣势：

1. 每一个版本都有固定数目的盐，有可能会被暴力枚举破解，但是这种情况我们只要换一组盐就好了，比如我们可以定期或者每次发版的时候来换盐，问题不大。
2. 盐生成的所有classname都在css文件中，较为好找，所以一定不能使用逗号连写的方式生成，且同一组不同盐的样式不要放到一起，增大被破解的难度。而且一定要做混淆。
3. 增大了css文件，但是量应该并不大，且能利用到缓存。

总结：

理论上有被暴力破解的可能，被暴力破解后就要换盐重新生成发布一次；css使用了外联的方式，可以利用到缓存。

因为会被暴力破解，所以也并不完美。暂时还是推荐使用方案二。

[评论直达连接](https://github.com/cnsnake11/blog/issues/27)
